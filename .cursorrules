# Agent-Lens Smart Microscopy Platform - Cursor Rules

## 1. Project Overview
Agent-Lens is an AI-powered smart microscopy web application that provides autonomous control of microscopy hardware with LLM-based AI agents. The platform integrates multiple microscope control, real-time image analysis, advanced data acquisition, and intelligent decision-making.

## 2. Architecture & Technology Stack

### 2.1. Core Technologies

#### Backend (Python)
- **Framework**: FastAPI with Hypha-RPC for service communication
- **Core Services**: 
  - Frontend service (`register_frontend_service.py`)
  - Similarity search service (`register_similarity_search_service.py`)
- **Key Libraries**: numpy, pillow, scikit-image, zarr, aiohttp, fastapi

#### Frontend (React)
- **Framework**: React 18 with Vite build system
- **Key Libraries**: 
  - Bootstrap 5 for responsive UI components
  - FontAwesome for icons
  - Hypha-RPC for backend communication
  - WinBox for window management
  - React Color for color picking
- **Styling**: CSS modules + Tailwind CSS + Bootstrap hybrid approach

#### Infrastructure
- **Containerization**: Docker with multi-service compose setup
- **CI/CD**: GitHub Actions with automatic Docker publishing
- **Storage**: S3-compatible artifact storage with MinIO
- **Deployment**: Hypha server platform with token-based authentication

### 2.2. Service Communication
- All services communicate via Hypha-RPC protocol
- Use workspace tokens for authentication
- Implement proper service discovery and connection handling
- Handle service timeouts and reconnection logic
- Use the HyphaServerManager for connection management

### 2.3. ASGI Frontend Service Architecture
- **Service Registration**: The `register_frontend_service.py` creates a FastAPI ASGI application and registers it with Hypha-RPC
- **Frontend Serving**: Static files from `/frontend/dist` are served directly by the ASGI app with proper caching headers
- **API Integration**: The ASGI service provides REST API endpoints that the React frontend consumes
- **Dual Purpose**: Single service acts as both static file server and dynamic API backend

#### Frontend Service Registration Pattern
```python
async def setup_service(server, server_id="agent-lens"):
    # Register ASGI service with Hypha-RPC
    await server.register_service({
        "id": server_id,
        "name": "Agent Lens", 
        "type": "asgi",           # Key: ASGI type registration
        "serve": get_frontend_api(),  # FastAPI app factory
        "config": {"visibility": "public"},
    })
```

#### Frontend Build & Deployment Integration
- **Build Process**: React app builds to `/frontend/dist` using Vite
- **Static Assets**: `/frontend/dist/assets` mounted at `/assets` endpoint
- **SPA Routing**: Root `/` serves `index.html` for React Router handling
- **Asset Optimization**: GZip compression middleware for bandwidth efficiency

#### API Endpoint Architecture
The ASGI service provides specialized microscopy API endpoints:

```python
# Data management endpoints  
@app.get("/datasets")  # List available time-lapse datasets
@app.get("/gallery-info")  # Gallery metadata and information
@app.get("/subfolders")  # Browse dataset file structure
@app.get("/file")  # Generate pre-signed URLs for file access
@app.get("/download")  # Direct file downloads with redirects

# OME-Zarr data access via artifact manager zip-files endpoint
# URL pattern: {SERVER_URL}/{workspace}/artifacts/{dataset_id}/zip-files/{zip_path}?path={chunk_path} or: {SERVER_URL}/{workspace}/artifacts/{dataset_id}/zip-files/{zip_path}~/{chunk_path}
# Example: https://hypha.aicell.io/agent-lens/artifacts/dataset123/zip-files/well_B2_96.zip/~/data.zarr/5/0.0.0.0.0
```

#### Frontend-Backend Communication Pattern
- **Base URL**: Frontend uses relative URLs that resolve to the same ASGI service
- **Authentication**: Workspace tokens handled server-side, frontend uses session-based access
- **Data Management**: React components call REST APIs for dataset browsing and configuration
- **OME-Zarr Data Access**: Direct HTTP requests to artifact manager zip-files endpoint for chunked data
- **Real-time Updates**: WebSocket connections (where needed) handled through Hypha-RPC integration

#### Performance Optimization Features
- **OME-Zarr Chunked Access**: Efficient data access via artifact manager zip-files endpoint with individual chunk requests
- **Request Queuing**: Priority-based data loading system with concurrent request management
- **Bandwidth Monitoring**: Request/response size logging for optimization
- **Client Disconnect Handling**: Graceful cleanup when clients abort requests
- **Data Compression**: Optimized data transfer with zip-compressed OME-Zarr chunks

#### Development vs Production Patterns
```python
# Service ID determination based on runtime context
is_connect_server = "connect-server" in cmd_args  # VSCode development
is_docker = "--docker" in cmd_args               # Container deployment
is_local = "--port" in cmd_args                  # Local development

# Different service IDs for different environments
service_id = "agent-lens-test" if (is_connect_server and not is_docker) else "agent-lens"
```

#### Error Handling & Monitoring
- **Middleware Logging**: Request processing time and bandwidth metrics
- **Health Probes**: Kubernetes readiness/liveness checks for service monitoring  
- **Graceful Degradation**: Empty tile responses (204) when data unavailable
- **Client Disconnect**: Proper 499 status codes for aborted requests

#### Integration with OME-Zarr Data Pipeline
- **OME-Zarr Format**: Standard 5D array (T, C, Z, Y, X) with multi-scale pyramid for microscopy data
- **Artifact Manager Integration**: Dataset and gallery management through Hypha artifacts with zip-files endpoint
- **Chunked Data Access**: Individual chunk requests via artifact manager zip-files endpoint for efficient loading
- **Multi-channel Support**: Efficient handling of multi-channel microscopy data with channel-specific zip files
- **Real-time Processing**: Progressive chunk loading with onChunkProgress callbacks for live updates

#### OME-Zarr Data Access Pattern
The system uses a sophisticated chunked data access pattern for efficient microscopy data loading:

```javascript
// Frontend: ArtifactZarrLoader service
const baseUrl = `${this.baseUrl}/${datasetId}/zip-files/well_${wellId}_96.zip/~/data.zarr/`;
const chunkUrl = `${baseUrl}${channel}/scale${scale}/${y}.zip?path=${x}`;
```

**Key Components:**
- **ArtifactZarrLoader**: Frontend service for OME-Zarr data access with caching and request management
- **Chunk Organization**: Data organized by channel, scale level, and spatial coordinates in zip files
- **Progressive Loading**: Real-time chunk loading with progress callbacks for responsive UI

### 2.4. Data Storage & Image Processing

#### Data Storage
- **Data Management**: 
  - OME-Zarr format with chunked data stored in zip files for efficient access
  - AgentLensArtifactManager for artifact and vector management
  - Artifact manager zip-files endpoint for high-performance chunked data serving
- **Storage Architecture**:
  - Use artifact manager for persistent storage
  - Implement dataset and gallery management
  - Support time-lapse data organization
  - Handle large file uploads/downloads with progress tracking
  - Implement proper metadata management

#### Image Processing Pipeline
- Support multiple image formats (uint8, uint16)
- Implement contrast/brightness adjustment
- Support multi-channel image composition
- Handle image annotations (points, polygons)
- Implement proper color mapping for fluorescence channels

## 3. Development Guidelines

### 3.1. File Organization
```
agent_lens/                 # Main Python package
├── __main__.py            # Entry point with CLI argument parsing
├── log.py                 # Logging configuration
├── register_frontend_service.py  # Frontend ASGI service registration
├── register_similarity_search_service.py  # Similarity search service
├── utils/                 # Utility modules
│   ├── artifact_manager.py    # Data storage and Zarr tile management
│   ├── register_sam_service.py  # SAM segmentation service registration
│   └── weaviate_search.py     # Similarity search utilities

tests/                     # Pytest test files (project root level)
├── test-frontend-components/  # Frontend component tests
│   ├── README.md                           # Test documentation
│   ├── run_tests.js                        # Main test runner
│   ├── test_tile_processing_manager.js     # TileProcessingManager tests
│   └── test_layer_panel.js                 # LayerPanel component tests
├── conftest.py           # Test configuration and fixtures
├── test_basic.py         # Basic functionality tests
├── test_artifact_manager.py  # Artifact manager tests
├── test_artifact_manager_basic.py  # Basic artifact manager tests
├── test_similarity_service.py  # Similarity service tests
├── test_frontend_service.py  # Frontend service tests (Playwright)
├── test_frontend_integration.js  # Frontend integration tests
├── test_artifact_zarr_loader.js  # Artifact Zarr loader tests
└── run_js_tests.sh       # JavaScript test runner script

frontend/                  # React application
├── main.jsx              # Root React component
├── main.css              # Global styles with input validation CSS classes
├── components/           # Reusable UI components
│   ├── annotation/       # Image annotation system
│   │   ├── AnnotationCanvas.jsx      # Canvas for drawing annotations
│   │   ├── AnnotationDetailsWindow.jsx  # Annotation details modal
│   │   ├── AnnotationPanel.css       # Annotation panel styles
│   │   ├── AnnotationPanel.jsx       # Main annotation control panel
│   │   └── SimilarAnnotationRenderer.jsx  # Similar annotation rendering
│   ├── microscope/       # Microscope-specific components
│   │   ├── controls/     # Microscope control interfaces
│   │   │   ├── NormalScanConfig.css  # Normal scan configuration styles
│   │   │   ├── NormalScanConfig.jsx  # Normal scan configuration panel
│   │   │   ├── QuickScanConfig.css   # Quick scan configuration styles
│   │   │   └── QuickScanConfig.jsx   # Quick scan configuration panel
│   │   └── map/          # Microscope map and data visualization
│   │       ├── ExperimentZarrManager.jsx     # OME-Zarr experiment data management
│   │       ├── LayerPanel.css               # Layer panel styles
│   │       ├── LayerPanel.jsx               # Layer control panel
│   │       ├── README_TileProcessingManager.md  # Tile processing documentation
│   │       └── TileProcessingManager.jsx    # Tile processing and caching
│   ├── CameraSettings.jsx        # Camera configuration component
│   ├── ChannelSettings.jsx       # Channel configuration component
│   ├── ChatbotButton.jsx         # AI chatbot interface button
│   ├── ControlButton.jsx         # Generic control button component
│   ├── DualRangeSlider.jsx       # Dual range slider component
│   ├── ImageJPanel.jsx           # ImageJ integration panel
│   ├── ImageSearchPanel.css      # Image search panel styles
│   ├── ImageSearchPanel.jsx      # Image similarity search interface
│   ├── ImagingTasksModal.css     # Imaging tasks modal styles
│   ├── ImagingTasksModal.jsx     # Time-lapse imaging task management
│   ├── IncubatorControl.jsx      # Automated incubator control
│   ├── LoginPrompt.jsx           # User authentication prompt
│   ├── LogSection.jsx            # System logs display
│   ├── MicroscopeControlPanel.jsx    # Main microscope control interface
│   ├── MicroscopeMapDisplay.css      # Microscope map display styles
│   ├── MicroscopeMapDisplay.jsx      # Main microscope map visualization
│   ├── Notification.jsx              # User notification system
│   ├── SampleSelector.jsx            # Sample management and transfer
│   ├── Sidebar.css                   # Main sidebar styles
│   └── Sidebar.jsx                   # Main application sidebar
├── utils/                # Frontend utility modules
│   ├── artifactZarrLoader.js  # OME-Zarr data loading service
│   ├── annotationEmbeddingService.js  # Annotation embedding service
│   ├── annotationUtils.js     # Annotation utility functions
│   └── previewImageUtils.js   # Image preview utilities
├── utils.jsx            # Utility functions, service connections, and input validation
├── package.json         # Frontend dependencies and scripts
└── vite.config.mjs      # Vite build configuration

docker/                   # Containerization
├── docker-compose-agent-lens-app.yml  # Main application compose
├── dockerfile           # Main application container
└── healthcheck.sh       # Health monitoring

scripts/                  # Development and deployment scripts
├── run_tests.py         # Comprehensive test runner
├── run_frontend_tests.py # Frontend service test runner
├── setup_dev.sh         # Development setup script
├── docker_start.sh      # Docker startup script
└── run_dev.sh           # Development server script

performance-analysis/     # Performance analysis tools
├── README.md            # Performance analysis documentation
├── chunk_performance_analysis.js  # Chunk loading performance tests
├── server_processing_bottleneck_analysis.js  # Server bottleneck analysis
└── parallel_curl_test.sh  # Parallel request testing
```

### 3.2. Coding Standards & Best Practices

#### Python
- Use async/await patterns consistently for all I/O operations
- Implement proper error handling with try/catch blocks and logging
- Use type hints for function parameters and return values
- Follow PEP 8 naming conventions (snake_case for functions/variables)
- Create rotating file handlers for logging with configurable levels
- Use dataclasses or Pydantic models for structured data
- Implement proper resource cleanup with context managers
- Use f-strings for string formatting

#### React
- Use functional components with hooks (useState, useEffect, useCallback)
- Implement proper prop validation with PropTypes
- Use camelCase for JavaScript variables and functions
- Create reusable components in the `/components` directory
- Implement proper cleanup in useEffect hooks
- Use async/await for API calls with error handling
- Optimize re-renders with useCallback and useMemo
- Follow React best practices for state management
- **MANDATORY**: Use `useValidatedNumberInput` hook for all number input fields to prevent NaN crashes
- Implement "Enter to confirm" behavior for better UX and data integrity
- Use consistent validation styling with `input-validation-container` pattern
- **AVOID HOISTING/DEPENDENCY ISSUES**: Always define all state variables and functions that are dependencies of `useCallback`, `useMemo`, or other hooks *before* the hooks that use them. This prevents runtime errors like 'Cannot access X before initialization'.

### 3.3. Performance Optimization
- Use OME-Zarr format for efficient large data handling with multi-scale pyramids
- Implement efficient data serving with artifact manager zip-files endpoint
- Use async/await patterns for non-blocking I/O operations
- Implement request queuing and priority-based data loading with concurrent request management
- Use zip compression for optimized data transfer of individual chunks
- Implement proper memory management for large datasets with cache cleanup

### 3.4. UI/UX Patterns
- Create responsive layouts that work on different screen sizes
- Implement collapsible panels for space optimization
- Provide real-time feedback for long-running operations
- Implement proper loading states and error handling
- Support keyboard shortcuts for common operations
- Use notification system for user feedback
- **Operation State Management**: Use global `currentOperation` state to disable UI during critical operations
- **UI Blocking**: Implement full-screen overlays and disabled interactions during sample transfers
- **Visual Feedback**: Show progress with spinners, workflow messages, and "not-allowed" cursors

#### Input Validation UI/UX Requirements
- **ALWAYS use validated inputs** for number fields to prevent NaN crashes
- **Visual validation feedback** with color-coded borders and icons
- **"Enter to confirm" behavior** - no immediate state updates on keystroke
- **Escape to cancel** - allow users to revert changes before confirming
- **Help text on hover/focus** - show valid ranges and usage hints
- **Consistent validation styling** across all components using `input-validation-container` pattern

## 4. Core Feature Implementation

### 4.1. Microscopy Domain Knowledge
- Understand multi-dimensional acquisition (X, Y, Z, time, channels)
- Handle different illumination channels (BF_LED_matrix_full, Fluorescence_405_nm_Ex, Fluorescence_488_nm_Ex, Fluorescence_561_nm_Ex, Fluorescence_638_nm_Ex, Fluorescence_730_nm_Ex)
- Implement proper camera exposure and intensity control
- Support autofocus algorithms (contrast-based and laser-based)
- Handle well plate navigation (96, 48, 24-well formats)
- Implement WebRTC for real-time video streaming from microscopes

### 4.2. Time-Lapse Imaging & Orchestration
- **Orchestrator Service**: Manages complex time-lapse imaging workflows and task scheduling
- **Local Hypha-RPC Setup**: Lab devices run on local hypha-rpc infrastructure for stability
- **Network Reliability**: Local setup reduces network issues and ensures consistent device communication
- **Task Management**: ImagingTasksModal component interfaces with orchestrator for task CRUD operations
- **Scheduling System**: Handles pending time points, imaging zones, and multi-device coordination
- **Real-Time Control**: Local orchestrator provides immediate response for hardware operations

### 4.3. Hardware Management & Sample Handling
- **Lab Setup**: One automated incubator with multiple slots, one robotic arm, two real microscopes
- **Sample Management**: SampleSelector component handles sample loading/unloading workflows
- **Conflict Prevention**: Implement proper scheduling and state management to avoid hardware collisions
- **Workflow Orchestration**: Coordinate between incubator, robotic arm, and microscope services
- **State Tracking**: Monitor sample locations and hardware status across all devices
- **Real vs Simulated**: Support both real hardware and simulated microscope modes
- **Operation Sequencing**: Ensure proper order of operations (home stage → arm transport → placement)
- **Multi-Microscope Support**: Handle reef-imaging/microscope-squid-1 and squid-2
- **Robotic Arm Integration**: Coordinate sample transport with reef-imaging/robotic-arm-control
- **Incubator Management**: Track sample slots and locations in automated incubator system
- **Operation Locking**: Prevent concurrent operations that could cause hardware conflicts
- **State Synchronization**: Maintain consistent state across incubator, arm, and microscope services
- **Error Recovery**: Implement rollback procedures for failed sample transfer operations
- **Sample Tracking**: Monitor sample locations (incubator_slot, robotic_arm, microscope1/2)

#### Service Handling Safety Notices
- **CRITICAL**: Always verify microscope homing success before robotic arm movement to prevent collisions
- **Service Verification**: Use `get_status()` method to verify microscope service functionality, not `.api()`
- **Specific Services**: Connect to specific microscope services (squid-1/squid-2) for transfer operations, not generic selected service
- **Safety Abort**: Immediately abort robotic arm operations if microscope operations fail
- **Emergency Cleanup**: Implement cleanup procedures to safely disconnect robotic arm on errors
- **Service Validation**: Check for essential methods (`home_stage`, `return_stage`) before proceeding with operations

### 4.4. AI Agent Integration
- Use vector embeddings for image similarity search
- Use LLM agents for microscopy control code generation
- Implement proper embedding reset and management
- Support chatbot integration for user assistance
- Use structured prompts for microscopy control
- Implement proper context management for long conversations
- Support multi-modal inputs (text + images)
- Provide clear feedback on AI decision-making
- Implement safety checks for hardware control
- Support different operating modes (autofocus, cell finding, dataset creation)

## 5. Testing Strategy

### 5.1. Test Infrastructure (✅ Working)
- **Framework**: pytest with asyncio support, Playwright for E2E testing
- **Dependencies**: CLIP, FAISS-CPU, torch for vector similarity tests, Playwright for browser testing
- **Test Runner**: `python scripts/run_tests.py` with multiple test types
- **Coverage**: pytest-cov for comprehensive coverage reporting
- **Frontend Testing**: Playwright integration for FastAPI service UI testing
- **Frontend Component Testing**: Vanilla JavaScript test runners for React components
- **Test Structure**: Tests located at project root level with comprehensive coverage

### 5.2. Test Categories & Execution
```bash
# Fast unit tests (< 2 seconds, recommended for development)
python scripts/run_tests.py --type fast

# Integration tests with service communication
python scripts/run_tests.py --type integration

# Slow tests with AI models (CLIP/FAISS vector similarity)
python scripts/run_tests.py --type slow

# Frontend service tests with Playwright
python scripts/run_tests.py --frontend-service

# Frontend component tests (vanilla JavaScript)
node tests/test-frontend-components/run_tests.js

# With coverage reporting
python scripts/run_tests.py --coverage

# Check dependencies only
python scripts/run_tests.py --check-deps
```

### 5.3. Writing Tests
- Use async/await patterns for microscopy operations
- For artifact manager tests: Use real connections without mocks for integration testing
- Test image processing with realistic microscopy data
- Create integration tests for service communication
- Follow test fixtures from `conftest.py` for consistent data
- Ensure `WORKSPACE_TOKEN` environment variable is set for integration tests
- Install package in development mode: `pip install -e .`
- **Frontend Service Testing**: Use Playwright for E2E browser testing of FastAPI services
- **Async Test Patterns**: Use `@pytest.mark.asyncio` decorator and proper fixture cleanup

### 5.4. Test Configuration (`pyproject.toml`)
```toml
[tool.pytest.ini_options]
asyncio_mode = "auto"
markers = [
    "unit: Unit tests",
    "integration: Integration tests", 
    "slow: Slow tests with AI models",
    "frontend: Frontend service tests"
]
filterwarnings = [
    "ignore:.*deprecated.*:DeprecationWarning",
    "ignore:.*PytestUnraisableExceptionWarning.*"
]
```

### 5.5. Common Testing Issues & Solutions
- **Async Cleanup**: Don't create custom `event_loop` fixtures that conflict with pytest-asyncio
- **Hypha Connections**: Use session-level fixtures with proper disconnect() cleanup
- **Playwright Setup**: Install browsers automatically with `playwright install` 
- **CI Dependencies**: Use container approach with pre-installed system libraries
- **Test Configuration**: Use `pyproject.toml` instead of `pytest.ini` for modern pytest setup
- **Async Decorators**: Always use `@pytest.mark.asyncio` for async test functions
- **Weaviate Collection Names**: Always use lowercase collection names, for example "Agentlenstest" instead of "AgentLensTest" - Weaviate normalizes collection names to lowercase internally

### 5.6. GitHub Actions CI/CD Patterns
```yaml
# Container-based testing for reliable dependency management
runs-on: ubuntu-24.04

# System dependencies for Playwright and networking
- name: Install system dependencies
  run: |
    apt-get update && apt-get install -y \
      curl wget ca-certificates \
      libnss3 libatk-bridge2.0-0 libdrm2 libxkbcommon0 \
      libgtk-3-0 libgbm-dev libasound2

# Step-by-step test execution
- name: Run unit tests
  run: python scripts/run_tests.py --type unit
- name: Run fast tests  
  run: python scripts/run_tests.py --type fast
- name: Run frontend service tests
  run: python scripts/run_tests.py --frontend-service
- name: Run frontend component tests
  run: node tests/test-frontend-components/run_tests.js
```

#### Docker Publishing Workflow
```yaml
# Build and publish Docker images
- name: Build and push Docker image
  uses: docker/build-push-action@v5.0.0
  with:
    context: .
    file: docker/Dockerfile
    push: ${{ github.event_name == 'push' }}
    tags: ${{ steps.meta.outputs.tags }}
    labels: ${{ steps.meta.outputs.labels }}
```

## 6. Deployment & Operations

### 6.1. Security
- Use token-based authentication for all services
- Implement proper CORS handling for cross-origin requests
- Use security headers and rate limiting
- Follow Docker security best practices (non-root user, minimal privileges)

### 6.2. Error Handling & Logging
- Use structured logging with timestamps and severity levels
- Implement proper exception handling for service calls
- Provide user-friendly error messages
- Log performance metrics for optimization
- Handle client disconnections gracefully

### 6.3. Monitoring
- Implement health checks for service monitoring

## 7. Contribution Guide

### 7.1. Code Review Checklist
- [ ] Async/await patterns used correctly
- [ ] Proper error handling and logging
- [ ] Type hints for Python functions
- [ ] PropTypes for React components
- [ ] Resource cleanup implemented
- [ ] Performance considerations addressed
- [ ] Security best practices followed
- [ ] Tests included for new functionality
- [ ] Documentation updated if needed
- [ ] **Number inputs use `useValidatedNumberInput` hook** (prevents NaN crashes)
- [ ] **Input validation uses `getInputValidationClasses` for background color feedback**
- [ ] **"Enter to confirm" behavior implemented for critical inputs**

### 7.2. Common Code Patterns

#### Input Validation Pattern (✅ Implemented System)
For all number input fields, use the validated input system to prevent NaN crashes and provide better UX:

```jsx
// Import validation utilities
import { useValidatedNumberInput, getInputValidationClasses } from '../utils';

// Create validation hook with appropriate constraints
const myNumberInput = useValidatedNumberInput(
  currentValue,                              // Current state value
  (newValue) => setState(newValue),         // State update function
  { 
    min: 0,                                 // Minimum allowed value
    max: 100,                               // Maximum allowed value
    allowFloat: true,                       // Allow decimal numbers
    allowEmpty: false                       // Whether empty input is valid
  },
  showNotification                          // Optional notification function
);

// Use in JSX with validation styling
<input
  type="number"
  value={myNumberInput.inputValue}
  onChange={myNumberInput.handleInputChange}
  onKeyDown={myNumberInput.handleKeyDown}    // Enter to confirm, Escape to cancel
  onBlur={myNumberInput.handleBlur}          // Confirm on focus loss
  className={getInputValidationClasses(
    myNumberInput.isValid,
    myNumberInput.hasUnsavedChanges,
    "base-input-classes"
  )}
  placeholder="Enter value"
/>
```

**Key Benefits:**
- **NaN Prevention**: Users can clear fields without causing crashes
- **"Enter to Confirm"**: Changes only apply when user presses Enter or loses focus
- **Visual Feedback**: Background color changes indicate validation state (normal/pending/error)
- **Consistent UX**: Same behavior across all number inputs in the application
- **Range Validation**: Automatic enforcement of min/max constraints

#### Service Registration Pattern
```python
async def setup_service(server, server_id="service-name"):
    """
    Set up the service with proper configuration.
    
    Args:
        server (Server): The server instance.
        server_id (str): Service identifier.
    """
    # Service configuration and registration
    await server.register_service({
        "id": server_id,
        "name": "Service Name",
        "type": "service",  # or "asgi" for frontend services
        "config": {"visibility": "public"},
        # Service methods and endpoints
    })
```

#### Frontend Service Registration Pattern
```python
async def setup_service(server, server_id="agent-lens"):
    """
    Set up the frontend ASGI service.
    
    Args:
        server (Server): The server instance.
        server_id (str): Service identifier.
    """
    # Register ASGI service with Hypha-RPC
    await server.register_service({
        "id": server_id,
        "name": "Agent Lens", 
        "type": "asgi",           # Key: ASGI type registration
        "serve": get_frontend_api(),  # FastAPI app factory
        "config": {"visibility": "public"},
    })
```

#### React Component Pattern
```jsx
const ComponentName = ({ prop1, prop2, onCallback }) => {
  const [state, setState] = useState(initialValue);
  
  useEffect(() => {
    // Setup and cleanup logic
    return () => {
      // Cleanup
    };
  }, [dependencies]);
  
  return <div>Component JSX</div>;
};

ComponentName.propTypes = {
  prop1: PropTypes.string.isRequired,
  prop2: PropTypes.number,
  onCallback: PropTypes.func.isRequired
};
```

#### Hardware Operation Pattern
```jsx
// Sample handling with proper state management and conflict prevention
const handleSampleOperation = async () => {
  if (currentOperation !== null || microscopeBusy) return;
  
  setCurrentOperation('transferring'); // Prevent concurrent operations & disable UI
  clearWorkflowMessages();
  
  try {
    addWorkflowMessage("Starting operation...");
    
    // CRITICAL: Verify microscope homing success before robotic arm movement
    const homeResult = await specificMicroscopeService.home_stage();
    if (homeResult && homeResult.success === false) {
      throw new Error(`Microscope homing failed: ${homeResult.message}`);
    }
    addWorkflowMessage("✓ Microscope safely homed - proceeding with robotic arm");
    
    // Only proceed with robotic arm if microscope is safe
    await roboticArmService.connect();
    armConnected = true;
    await roboticArmService.light_on();
    armLightOn = true;
    
    await coordinateWithServices();
    addWorkflowMessage("Operation completed successfully");
    setCurrentOperation(null); // Re-enable UI
  } catch (error) {
    addWorkflowMessage(`Error: ${error.message}`);
    await rollbackOperation();
    setCurrentOperation(null); // Re-enable UI even on error
  }
};
```
**UI Blocking**: When `currentOperation` is set, the entire interface is disabled with overlays and visual feedback.
**Emergency**: Use 'roboticArmService.halt()' for immediate stop.

#### Async Error Handling Pattern
```python
try:
    result = await some_async_operation()
    logger.info(f"Operation successful: {result}")
    return result
except Exception as e:
    logger.error(f"Operation failed: {e}", exc_info=True)
    raise
```

#### Async Test Fixture Pattern
```python
@pytest.fixture
async def hypha_server():
    """Session-level Hypha server connection with proper cleanup"""
    server = None
    try:
        server = await connect_to_server({
            "server_url": "https://ai.imjoy.io",
            "workspace": workspace_name,
            "token": workspace_token
        })
        yield server
    finally:
        if server:
            await server.disconnect()
```

---
*Remember: This is a research platform for autonomous microscopy. Prioritize reliability, performance, and scientific accuracy in all implementations.* 

## 8. Development Notes

### 8.1. Frontend Development
- When starting the frontend webapp (`npm start`), a circular dependency check (madge) is run automatically before the app launches. This ensures no import cycles are present in the codebase.
- The frontend uses a hybrid styling approach: Bootstrap 5 + Tailwind CSS + CSS modules for maximum flexibility.
- All number inputs must use the `useValidatedNumberInput` hook to prevent NaN crashes and provide consistent UX.

### 8.2. Performance Considerations
- The platform includes performance analysis tools in the `performance-analysis/` directory for optimizing chunk loading and server processing.
- OME-Zarr data access uses efficient chunked loading with zip compression for optimal bandwidth usage.
- Frontend component testing uses vanilla JavaScript test runners for better performance and reliability. 