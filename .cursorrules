# Agent-Lens Smart Microscopy Platform - Cursor Rules

## Project Overview
Agent-Lens is an AI-powered smart microscopy web application that provides autonomous control of microscopy hardware with LLM-based AI agents. The platform integrates multiple microscope control, real-time image analysis, advanced data acquisition, and intelligent decision-making.

## Technology Stack & Architecture

### Backend (Python)
- **Framework**: FastAPI with Hypha-RPC for service communication
- **Core Services**: 
  - Frontend service (`register_frontend_service.py`)
  - Similarity search service (`register_similarity_search_service.py`)
- **Data Management**: 
  - Zarr format for efficient tile-based image storage
  - AgentLensArtifactManager for artifact and vector management
  - ZarrTileManager for high-performance tile serving
- **Key Libraries**: numpy, pillow, scikit-image, zarr, aiohttp, fastapi
- **Testing**: pytest with async support

### Frontend (React)
- **Framework**: React 18 with Vite build system
- **Key Libraries**: 
  - OpenLayers for high-performance image display and interaction
  - Bootstrap 5 for responsive UI components
  - FontAwesome for icons
  - Hypha-RPC for backend communication
  - WinBox for window management
  - React Color for color picking
- **Styling**: CSS modules + Tailwind CSS + Bootstrap hybrid approach

### Infrastructure
- **Containerization**: Docker with multi-service compose setup
- **CI/CD**: GitHub Actions with automatic Docker publishing
- **Storage**: S3-compatible artifact storage with MinIO
- **Deployment**: Hypha server platform with token-based authentication

## Coding Standards & Best Practices

### Python Code Standards
- Use async/await patterns consistently for all I/O operations
- Implement proper error handling with try/catch blocks and logging
- Use type hints for function parameters and return values
- Follow PEP 8 naming conventions (snake_case for functions/variables)
- Create rotating file handlers for logging with configurable levels
- Use dataclasses or Pydantic models for structured data
- Implement proper resource cleanup with context managers
- Use f-strings for string formatting

### React Code Standards  
- Use functional components with hooks (useState, useEffect, useCallback)
- Implement proper prop validation with PropTypes
- Use camelCase for JavaScript variables and functions
- Create reusable components in the `/components` directory
- Implement proper cleanup in useEffect hooks
- Use async/await for API calls with error handling
- Optimize re-renders with useCallback and useMemo
- Follow React best practices for state management

### File Organization
```
agent_lens/                 # Main Python package
├── __main__.py            # Entry point with CLI argument parsing
├── artifact_manager.py    # Data storage and Zarr tile management
├── register_*_service.py  # Service registration modules

tests/                     # Pytest test files (project root level)
├── conftest.py           # Test configuration and fixtures
├── test_basic.py         # Basic functionality tests
├── test_artifact_manager.py  # Artifact manager tests
└── test_similarity_service.py  # Similarity service tests

frontend/                  # React application
├── main.jsx              # Root React component
├── components/           # Reusable UI components
├── utils.jsx            # Utility functions and service connections
└── main.css             # Global styles

docker/                   # Containerization
├── docker-compose-*.yml  # Multi-service configurations
├── dockerfile           # Main application container
└── healthcheck.sh       # Health monitoring

scripts/                  # Development and deployment scripts
docs/                    # Documentation and diagrams
```

## Development Guidelines

### Microscopy Domain Knowledge
- Understand multi-dimensional acquisition (X, Y, Z, time, channels)
- Handle different illumination channels (BF, fluorescence: F405, F488, F561, F638, F730)
- Implement proper camera exposure and intensity control
- Support autofocus algorithms (contrast-based and laser-based)
- Handle well plate navigation (96, 48, 24-well formats)
- Implement WebRTC for real-time video streaming from microscopes

### AI Integration Patterns
- Use vector embeddings for image similarity search
- Use LLM agents for microscopy control code generation
- Implement proper embedding reset and management
- Support chatbot integration for user assistance

### Hardware Management & Sample Handling
- **Lab Setup**: One automated incubator with multiple slots, one robotic arm, two real microscopes
- **Sample Management**: SampleSelector component handles sample loading/unloading workflows
- **Conflict Prevention**: Implement proper scheduling and state management to avoid hardware collisions
- **Workflow Orchestration**: Coordinate between incubator, robotic arm, and microscope services
- **State Tracking**: Monitor sample locations and hardware status across all devices
- **Real vs Simulated**: Support both real hardware and simulated microscope modes
- **Operation Sequencing**: Ensure proper order of operations (home stage → arm transport → placement)

### Performance Optimization
- Use Zarr format for efficient large image data handling
- Implement tile-based image serving with LRU caching
- Use async/await patterns for non-blocking I/O operations
- Implement request queuing and priority-based tile loading
- Use compression for image data transfer (WebP/PNG)
- Implement proper memory management for large datasets

### UI/UX Patterns
- Create responsive layouts that work on different screen sizes
- Implement collapsible panels for space optimization
- Use OpenLayers for smooth pan/zoom image interaction
- Provide real-time feedback for long-running operations
- Implement proper loading states and error handling
- Support keyboard shortcuts for common operations
- Use notification system for user feedback

## Specific Implementation Notes

### Service Communication
- All services communicate via Hypha-RPC protocol
- Use workspace tokens for authentication
- Implement proper service discovery and connection handling
- Handle service timeouts and reconnection logic
- Use the HyphaServerManager for connection management

### Time-Lapse Imaging & Orchestration
- **Orchestrator Service**: Manages complex time-lapse imaging workflows and task scheduling
- **Local Hypha-RPC Setup**: Lab devices run on local hypha-rpc infrastructure for stability
- **Network Reliability**: Local setup reduces network issues and ensures consistent device communication
- **Task Management**: ImagingTasksModal component interfaces with orchestrator for task CRUD operations
- **Scheduling System**: Handles pending time points, imaging zones, and multi-device coordination
- **Real-Time Control**: Local orchestrator provides immediate response for hardware operations

### Hardware Coordination & Safety
- **Multi-Microscope Support**: Handle reef-imaging/mirror-microscope-control-squid-1 and squid-2
- **Robotic Arm Integration**: Coordinate sample transport with reef-imaging/mirror-robotic-arm-control
- **Incubator Management**: Track sample slots and locations in automated incubator system
- **Operation Locking**: Prevent concurrent operations that could cause hardware conflicts
- **State Synchronization**: Maintain consistent state across incubator, arm, and microscope services
- **Error Recovery**: Implement rollback procedures for failed sample transfer operations
- **Sample Tracking**: Monitor sample locations (incubator_slot, robotic_arm, microscope1/2)

### Image Processing Pipeline
- Support multiple image formats (uint8, uint16)
- Implement contrast/brightness adjustment
- Support multi-channel image composition
- Handle image annotations (points, polygons)
- Implement proper color mapping for fluorescence channels

### Data Storage Architecture
- Use artifact manager for persistent storage
- Implement dataset and gallery management
- Support time-lapse data organization
- Handle large file uploads/downloads with progress tracking
- Implement proper metadata management

### Error Handling & Logging
- Use structured logging with timestamps and severity levels
- Implement proper exception handling for service calls
- Provide user-friendly error messages
- Log performance metrics for optimization
- Handle client disconnections gracefully

## Testing Guidelines

### **Test Infrastructure** (✅ Working)
- **Framework**: pytest with asyncio support, React Testing Library, Playwright for E2E
- **Dependencies**: CLIP, FAISS-CPU, torch for vector similarity tests, Playwright for browser testing
- **Test Runner**: `python scripts/run_tests.py` with multiple test types
- **Coverage**: pytest-cov for comprehensive coverage reporting
- **Frontend Testing**: Playwright integration for FastAPI service UI testing

### **Test Categories**
```bash
# Fast unit tests (< 2 seconds, recommended for development)
python scripts/run_tests.py --type fast

# Integration tests with service communication
python scripts/run_tests.py --type integration

# Slow tests with AI models (CLIP/FAISS vector similarity)
python scripts/run_tests.py --type slow

# Frontend service tests with Playwright
python scripts/run_tests.py --frontend-service

# With coverage reporting
python scripts/run_tests.py --coverage
```

### **Writing Tests**
- Use async/await patterns for microscopy operations
- For artifact manager tests: Use real connections without mocks for integration testing
- Test image processing with realistic microscopy data
- Create integration tests for service communication
- Follow test fixtures from `conftest.py` for consistent data
- Ensure `WORKSPACE_TOKEN` environment variable is set for integration tests
- Install package in development mode: `pip install -e .`
- **Frontend Service Testing**: Use Playwright for E2E browser testing of FastAPI services
- **Async Test Patterns**: Use `@pytest.mark.asyncio` decorator and proper fixture cleanup

### **Test Configuration** (pyproject.toml)
```toml
[tool.pytest.ini_options]
asyncio_mode = "auto"
markers = [
    "unit: Unit tests",
    "integration: Integration tests", 
    "slow: Slow tests with AI models",
    "frontend: Frontend service tests"
]
filterwarnings = [
    "ignore:.*deprecated.*:DeprecationWarning",
    "ignore:.*PytestUnraisableExceptionWarning.*"
]
```

### **Test Patterns**
```python
# Unit test example
@pytest.mark.unit
def test_image_processing(sample_image):
    processed = apply_contrast_enhancement(sample_image)
    assert processed.size == sample_image.size

# Integration test with real connections (artifact manager)
@pytest.mark.integration
async def test_tile_manager_workflow(tile_manager):
    # Uses real ZarrTileManager connection
    tile_data = await tile_manager.get_tile_np_data("dataset", "channel", 0, 0, 0)
    if tile_data is not None:
        assert isinstance(tile_data, np.ndarray)

# Slow test with AI models
@pytest.mark.slow  
async def test_similarity_search():
    # Uses real CLIP/FAISS for vector similarity
    results = await find_similar_cells(query_image, top_k=5)
    assert len(results) <= 5

# Frontend service test with Playwright
@pytest.mark.frontend
@pytest.mark.asyncio
async def test_frontend_service_ui(frontend_service_url, playwright):
    browser = await playwright.chromium.launch()
    page = await browser.new_page()
    await page.goto(frontend_service_url)
    
    # Test UI elements
    title = await page.title()
    assert "Agent-Lens" in title
    
    # Take screenshot for debugging
    await page.screenshot(path="test_screenshot.png")
    await browser.close()

# Proper async fixture pattern
@pytest.fixture
async def hypha_server():
    """Session-level Hypha server connection with proper cleanup"""
    server = None
    try:
        server = await connect_to_server({
            "server_url": "https://ai.imjoy.io",
            "workspace": workspace_name,
            "token": workspace_token
        })
        yield server
    finally:
        if server:
            await server.disconnect()

# Test environment setup
def setup_test_imports():
    import sys
    from pathlib import Path
    project_root = Path(__file__).parent.parent
    if str(project_root) not in sys.path:
        sys.path.insert(0, str(project_root))
```

### **Test Status** (✅ Current)
- **Basic Tests**: 11 tests passing, core functionality verified
- **Similarity Service**: Working with CLIP embeddings and FAISS indexing
- **Mock Infrastructure**: Comprehensive fixtures for microscopy simulation
- **Frontend Service**: Playwright E2E testing with browser automation
- **Async Patterns**: Proper async/await cleanup without pytest warnings
- **CI/CD Ready**: GitHub Actions integration with container-based testing

### **GitHub Actions CI/CD Patterns**
```yaml
# Container-based testing for reliable dependency management
runs-on: ubuntu-latest
container: python:3.11-slim

# System dependencies for Playwright and networking
- name: Install system dependencies
  run: |
    apt-get update && apt-get install -y \
      curl wget ca-certificates \
      libnss3 libatk-bridge2.0-0 libdrm2 libxkbcommon0 \
      libgtk-3-0 libgbm-dev libasound2

# Step-by-step test execution
- name: Run unit tests
  run: python scripts/run_tests.py --type unit
- name: Run fast tests  
  run: python scripts/run_tests.py --type fast
- name: Run React tests
  run: cd frontend && npm test -- --coverage --watchAll=false
```

### **Common Testing Issues & Solutions**
- **Async Cleanup**: Don't create custom `event_loop` fixtures that conflict with pytest-asyncio
- **Hypha Connections**: Use session-level fixtures with proper disconnect() cleanup
- **Playwright Setup**: Install browsers automatically with `playwright install` 
- **CI Dependencies**: Use container approach with pre-installed system libraries
- **Test Configuration**: Use `pyproject.toml` instead of `pytest.ini` for modern pytest setup
- **Async Decorators**: Always use `@pytest.mark.asyncio` for async test functions

## Security & Deployment
- Use token-based authentication for all services
- Implement proper CORS handling for cross-origin requests
- Use security headers and rate limiting
- Follow Docker security best practices (non-root user, minimal privileges)
- Implement health checks for service monitoring

## Code Review Checklist
- [ ] Async/await patterns used correctly
- [ ] Proper error handling and logging
- [ ] Type hints for Python functions
- [ ] PropTypes for React components
- [ ] Resource cleanup implemented
- [ ] Performance considerations addressed
- [ ] Security best practices followed
- [ ] Tests included for new functionality
- [ ] Documentation updated if needed

## Common Patterns to Follow

### Service Registration Pattern
```python
async def setup_service(server, server_id="service-name"):
    # Service configuration and registration
    await server.register_service(service_config)
```

### React Component Pattern
```jsx
const ComponentName = ({ prop1, prop2, onCallback }) => {
  const [state, setState] = useState(initialValue);
  
  useEffect(() => {
    // Setup and cleanup logic
    return () => {
      // Cleanup
    };
  }, [dependencies]);
  
  return <div>Component JSX</div>;
};

ComponentName.propTypes = {
  prop1: PropTypes.string.isRequired,
  prop2: PropTypes.number,
  onCallback: PropTypes.func.isRequired
};
```

### Hardware Operation Pattern
```jsx
// Sample handling with proper state management and conflict prevention
const handleSampleOperation = async () => {
  if (currentOperation !== null || microscopeBusy) return;
  
  setCurrentOperation('loading'); // Prevent concurrent operations
  clearWorkflowMessages();
  
  try {
    addWorkflowMessage("Starting operation...");
    await validateHardwareState();
    await coordinateWithServices();
    addWorkflowMessage("Operation completed successfully");
    setCurrentOperation(null);
  } catch (error) {
    addWorkflowMessage(`Error: ${error.message}`);
    await rollbackOperation();
    setCurrentOperation(null);
  }
};
```

### Async Error Handling Pattern
```python
try:
    result = await some_async_operation()
    logger.info(f"Operation successful: {result}")
    return result
except Exception as e:
    logger.error(f"Operation failed: {e}", exc_info=True)
    raise
```

## AI Agent Integration
When implementing AI agent functionality:
- Use structured prompts for microscopy control
- Implement proper context management for long conversations
- Support multi-modal inputs (text + images)
- Provide clear feedback on AI decision-making
- Implement safety checks for hardware control
- Support different operating modes (autofocus, cell finding, dataset creation)

## Time-Lapse Imaging Workflows
When implementing time-lapse functionality:
- Use the orchestrator service for task scheduling and execution
- Leverage local hypha-rpc setup for reliable device communication
- Implement proper time point generation and management
- Support well plate imaging zones with configurable FOV grids
- Handle illumination settings per channel with intensity/exposure control
- Coordinate between incubator sample handling and imaging schedules
- Provide real-time workflow progress feedback to users

Remember: This is a research platform for autonomous microscopy. Prioritize reliability, performance, and scientific accuracy in all implementations. 