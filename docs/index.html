<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Microscope Control</title>
    <script src="https://cdn.jsdelivr.net/npm/imjoy-rpc@0.5.48-post1/dist/hypha-rpc-websocket.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/17.0.2/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/17.0.2/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- Include WinBox CSS -->
    <script src="https://rawcdn.githack.com/nextapps-de/winbox/0.2.82/dist/winbox.bundle.min.js"></script>    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: 'Roboto', sans-serif;  
        overflow-y: auto;
      }

      h1, h2, h3 {
        font-weight: 700; /* Fetstil */
      }
      
      label, button, h3 {
        font-weight: 500; /* Medium */
      }
      
      body, p, input, select {
        font-weight: 400; /* Vanlig */
      }

      #control-chat-section .section-title {
        margin-top: 15px; /* Adjust the value as needed */
      }

      .section-title {
        font-size: 24px;     /* Adjust to match the "Actions" header size */
        font-weight: 500;    /* Medium weight to match "Actions" */
        margin-bottom: 20px; /* Consistent spacing below headers */
      }
      
      #image-display {
        position: relative;
        width: 50%;
        height: 60vh; /* Use viewport height for responsiveness */
        border: 1px solid #ccc;
        box-sizing: border-box;
        background-color: #f0f0f0;
        float: left;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow-x: auto; /* Add this line */
        overflow-y: auto; /* Ensure vertical scrolling is also enabled if needed */
      }

      /* Position the Chatbot button in the upper right corner */
      .chatbot-button {
        position: absolute;
        top: 10px;
        right: 23px;
        padding: 10px 15px;
        z-index: 1000; /* Ensure it appears above other elements */
        background-color: #28a745; /* Green background */
        color: #fff;
        border: none;
        border-radius: 6px;
        font-size: 16px;
        font-weight: 500;
        cursor: pointer;
        box-shadow:
          inset 0 -3px 0 rgba(0, 0, 0, 0.2),
          0 4px 6px rgba(0, 0, 0, 0.1);
        transition: background 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
      }

      .chatbot-button:hover {
        background-color: #218838; /* Darker green on hover */
        box-shadow:
          inset 0 -3px 0 rgba(0, 0, 0, 0.2),
          0 6px 8px rgba(0, 0, 0, 0.15);
        transform: translateY(-2px);
      }

      .chatbot-button .icon {
        margin-right: 8px;
      }

      /* Ensure the parent container is positioned relatively */
      body, #app {
        position: relative;
      }
      
      .placeholder-text {
        font-size: 24px;
        color: #555;
      }
      
      #action-similarity-container {
        display: flex;
        width: 100%;
        height: 40vh; /* Use viewport height for responsiveness */
        box-sizing: border-box;
      }
      
      #actions {
        width: 50%;
        padding: 10px;
        border-right: 1px solid #ccc;
        box-sizing: border-box;
        height: 100%;
        text-align: left;
        padding-left: 20px;  /* Adjust the value as needed */
        padding-right: 20px; /* Adjust the value as needed */
      }
      
      #similarity-search {
        width: 50%;
        padding: 10px;
        box-sizing: border-box;
        height: 100%;
        background-color: #f9f9f9;
        display: flex;
        flex-direction: column; /* Added for proper flex behavior */
      }
      
      #control-chat-section {
        position: relative;
        top: 0;
        right: 0;
        width: 50%;
        height: 60vh; /* Use viewport height for responsiveness */
        border-left: 1px solid #ccc;
        box-sizing: border-box;
        float: right;
        display: flex;
        flex-direction: column; /* Added for proper flex behavior */
        padding-left: 20px;  /* Adjust the value as needed */
        padding-right: 20px; /* Adjust the value as needed */
      }
      
      #log-section {
        margin-top: 10px;
        width: 100%;
        background-color: #fafafa;
        padding: 10px;
        border-top: 1px solid #ccc;
        box-sizing: border-box;
      }

      input[readonly] {
        background-color: #e4e1e1; /* Ljusgrå bakgrund */
        cursor: default; /* Ändra muspekaren till standardpekare */
      }
    
      .icon {
        margin-right: 8px; /* Justera avståndet mellan ikonen och texten */
      }
      

      .illumination-control-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        gap: 10px;
      }
    
      .illumination-item {
          flex: 1;
      }
    
      .control-input {
          width: 100%;
          box-sizing: border-box;
      }

      .control-button {
        flex: 1; /* Allows buttons to share available space equally */
        padding:2px;
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
        text-align: center;
      }
      
      .control-button:hover {
        background-color: #0056b3;
      }
      
      .control-input {
        margin: 5px 0;
        padding: 8px;
        width: 100%;
        box-sizing: border-box;
      }
      
      .coordinate-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
      }
      
      .coordinate-container {
        display: flex;
        justify-content: space-between;
        gap: 20px;
      }
      
      .aligned-buttons {
        display: flex;
        justify-content: space-between;
        width: 100%;
      }
      
      .half-button {
        width: 49%;
        padding: 7px;
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
        text-align: center;
      }
      
      .half-button:hover {
        background-color: #0056b3;
      }
      
      .horizontal-buttons {
        display: flex;
        justify-content: space-between;
        width: 100%;
        gap: 20px; /* Add gap between buttons */
      }
      
      .large-button {
        padding: 10px;
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
        text-align: center;
      }
      
      .large-button:hover {
        background-color: #0056b3;
      }
      
      .snap-button {
        background: linear-gradient(135deg, #27AE60, #2ECC71);
      }

      .snap-button:hover {
        background: linear-gradient(135deg, #2ECC71, #27AE60);
      }

      label {
        margin-top: 20px;
        display: block;
      }
      
      .control-group {
        display: flex;
        justify-content: center;
        flex-direction: column;
        align-items: flex-start;
        margin-top: 15px;
      }
      
      .log-content {
        max-height: 200px;
        overflow-y: auto;
        background-color: #e9ecef;
        padding: 10px;
      }
      
      .illumination-settings {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
      }
      
      .illumination-intensity,
      .illumination-channel {
        width: 49%; /* Adjust the width as needed to fit in the current window */
        box-sizing: border-box;
      }

      .intensity-label-row {
        display: flex;
        align-items: center;
      }

      .intensity-label-row label,
      .intensity-label-row span {
        display: inline;
        margin: 10px;
        margin-top: auto;
      }
      
      .illumination-intensity label,
      .illumination-channel label {
        display: block;
        margin-bottom: 10px;
        margin-top: 15px;
      }
      
      .illumination-intensity input[type="range"] {
        width: 100%;
        margin-top: 10px;
      }

      .illumination-channel label {
        margin-top: 15px;
      }
      
      .illumination-channel select {
        width: 100%;
        margin-bottom: 5px;
      }
      
      .illumination-channel button {
        width: 100%;
      }

      .camera-exposure-settings {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
      }

      .camera-exposure-settings label {
        margin-top: 2px; /* Decrease the margin-top as needed */
      }
      
      .camera-exposure-row {
        display: flex;
        align-items: center;
      }
      
      .camera-exposure-row label {
        margin-right: 10px;
      }
      
      .camera-exposure-input {
        width: 340px; /* Adjust this width as needed */
        box-sizing: border-box;
      }

      .reset-button {
        padding: 3px;
        background: linear-gradient(135deg, #fca61f, #f39c12); /* Orange färg */
      }
      
      .reset-button:hover {
        background: linear-gradient(135deg, #f39c12, #c38013); /* Mörkare röd vid hovring */
      }

      .actions-buttons {
        display: flex;
        justify-content: flex-start;
        gap: 20px; /* Behåll avståndet mellan knapparna */
      }

      .actions-button {
        padding: 10px;
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
        text-align: center;
      }
      
      .actions-button:hover {
        background-color: #0056b3;
      }
      
      button {
        /* Common styles for all buttons */
        padding: 12px 20px;
        color: #fff;
        border: none;
        cursor: pointer;
        text-align: center;
        border-radius: 6px;
        font-size: 16px;
        font-weight: 500;
      
        /* Modern styling */
        background: linear-gradient(135deg, #007bff, #0185b1);
        box-shadow:
          inset 0 -3px 0 rgba(0, 0, 0, 0.2),
          0 4px 6px rgba(0, 0, 0, 0.1);
      
        /* Smooth transitions */
        transition: background 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
      }
      
      button:hover {
        background: linear-gradient(135deg, #00bfff, #007bff);
        box-shadow:
          inset 0 -3px 0 rgba(0, 0, 0, 0.2),
          0 6px 8px rgba(0, 0, 0, 0.15);
        transform: translateY(-2px);
      }
      

      button, input {
        border-radius: 10px; /* Adjust corners */
      }

    </style>
</head>
<body>
<div id="app"></div>

<!-- Include WinBox JS -->
<script src="https://unpkg.com/winbox@0.2.9/dist/winbox.bundle.min.js"></script>
<!-- Include hypha-core -->
<script type="module">
  import { HyphaCore } from "https://cdn.jsdelivr.net/npm/hypha-core@0.20.38/dist/hypha-core.mjs";

  window.hyphaCoreInitialized = false;
  window.initializeHyphaCore = async () => {
    if (!window.hyphaCoreInitialized) {
      window.hyphaCoreInitialized = true;
      window.hyphaCore = new HyphaCore();
      window.chatbotWindow = null;

      window.hyphaCore.on("add_window", (config) => {
        const wb = new WinBox(config.name || config.src.slice(0, 128), {
          background: "#448aff",
          x: "center",
          y: "center",
          width: "40%",
          height: "70%",
          movable: true,
          resizable: true,
        });
        wb.body.innerHTML = `<iframe src="${config.src}" style="width: 100%; height: 100%; border: none;"></iframe>`;
        return wb;
      });

      await window.hyphaCore.start();
      window.hyphaApi = window.hyphaCore.api;
    }
  };
</script>

<script type="text/babel">
const { useState, useEffect, useRef } = React;
const originalWidth = 2048;
const originalHeight = 2048;

const MicroscopeControl = () => {
    const canvasRef = useRef(null);
    const [microscopeControl, setMicroscopeControl] = useState(null);
    const [snapshotImage, setSnapshotImage] = useState(null);

    const [xPosition, setXPosition] = useState(0);
    const [yPosition, setYPosition] = useState(0);
    const [zPosition, setZPosition] = useState(0);
    const [BrightFieldIntensity, setBrightFieldIntensity] = useState(50);
    const [BrightFieldCameraExposure, setBrightFieldCameraExposure] = useState(100);
    const [Fluorescence405Intensity, setFluorescence405Intensity] = useState(50);
    const [Fluorescence405CameraExposure, setFluorescence405CameraExposure] = useState(100);
    const [Fluorescence488Intensity, setFluorescence488Intensity] = useState(50);
    const [Fluorescence488CameraExposure, setFluorescence488CameraExposure] = useState(100);
    const [Fluorescence561Intensity, setFluorescence561Intensity] = useState(50);
    const [Fluorescence561CameraExposure, setFluorescence561CameraExposure] = useState(100);
    const [Fluorescence638Intensity, setFluorescence638Intensity] = useState(50);
    const [Fluorescence638CameraExposure, setFluorescence638CameraExposure] = useState(100);
    const [Fluorescence730Intensity, setFluorescence730Intensity] = useState(50);
    const [Fluorescence730CameraExposure, setFluorescence730CameraExposure] = useState(100);
    const [illuminationIntensity, setIlluminationIntensity] = useState(50);
    const [illuminationChannel, setIlluminationChannel] = useState("0");
    const [cameraExposure, setCameraExposure] = useState(100);
    const [xMove, setXMove] = useState(1);
    const [yMove, setYMove] = useState(1);
    const [zMove, setZMove] = useState(0.1);
    const [isLightOn, setIsLightOn] = useState(false);
    const [isPlateScanRunning, setIsPlateScanRunning] = useState(false);
    const [log, setLog] = useState('');
    const [chatbotUrl, setChatbotUrl] = useState(null);
    const [svc, setSvc] = useState(null);  // Correctly initialize the similarity search service state
    const [numSimilarResults, setNumSimilarResults] = useState(5);
    const [searchResults, setSearchResults] = useState([]);
    const [isLoading, setIsLoading] = useState(false);
    const [isPenActive, setIsPenActive] = useState(false); // State to track if the pen tool is active
    const [isFirstClick, setIsFirstClick] = useState(true); // Track if it's the first click for segmentation
    const [segmentService, setSegmentService] = useState(null);
    const [labels, setLabels] = useState([]);
    const [activeLabel, setActiveLabel] = useState(null);
    const [selectedModel, setSelectedModel] = useState('vit_b_lm'); // Default model
    const [similarityService, setSimilarityService] = useState(null);
    const [isBoxSelectionActive, setIsBoxSelectionActive] = useState(false);
    const [isDrawing, setIsDrawing] = useState(false);
    const [startPoint, setStartPoint] = useState({ x: 0, y: 0 });
    const [annotations, setAnnotations] = useState([]);
    const appendLog = (message) => {
        setLog(prevLog => prevLog + message + '\n');
    };

    useEffect(() => {
      const initializeWebRPC = async () => {
          try {
              appendLog('Connecting to server...');
              const server = await hyphaWebsocketClient.connectToServer({ 
                  "name": "js-client", 
                  "server_url": "https://ai.imjoy.io", 
                  "method_timeout": 10 
              });
              appendLog('Server connected.');
              appendLog('Getting imasfadsfdsdfasfdsad.');

              appendLog('Getting Segmentation service...');
              try {
                  const segmentationService = await server.get_service("interactive-segmentation");
                  appendLog('Segmentation service acquired.');
                  setSegmentService(segmentationService);  // Set the segmentation service
              } catch (segmentationError) {
                  appendLog(`Error acquiring segmentation service: ${segmentationError.message}`);
              }
              
              appendLog('Getting microscope control service...');
              const mc = await server.get_service("microscope-control-squid-test");
              appendLog('Microscope control service acquired.');

              appendLog('Getting image-embedding-similarity-search service...');
              const similarityService = await server.get_service("image-embedding-similarity-search");
              appendLog('Similarity search service acquired.');
              console.log('Acquired similarity service:', similarityService);
              setSimilarityService(similarityService);
  
              setMicroscopeControl(mc);
                          // Poll the server for status updates every 5 seconds
              const statusInterval = setInterval(async () => {
                try {
                    const status = await mc.get_status();
                    updateUIBasedOnStatus(status); // Call function to update UI
                } catch (statusError) {
                    appendLog(`Error fetching status: ${statusError.message}`);
                }
              }, 2000); // Poll every 2 seconds

              // Clear the interval when the component unmounts
              return () => clearInterval(statusInterval);
            
          } catch (error) {
              appendLog(`Error: ${error.message}`);
          }
      };
  
      initializeWebRPC();
    }, []);
  
    useEffect(() => {
      switch (illuminationChannel) {
        case "0":
          setIlluminationIntensity(BrightFieldIntensity);
          setCameraExposure(BrightFieldCameraExposure);
          break;
        case "11":
          setIlluminationIntensity(Fluorescence405Intensity);
          setCameraExposure(Fluorescence405CameraExposure);
          break;
        case "12":
          setIlluminationIntensity(Fluorescence488Intensity);
          setCameraExposure(Fluorescence488CameraExposure);
          break;
        case "14":
          setIlluminationIntensity(Fluorescence561Intensity);
          setCameraExposure(Fluorescence561CameraExposure);
          break;
        case "13":
          setIlluminationIntensity(Fluorescence638Intensity);
          setCameraExposure(Fluorescence638CameraExposure);
          break;
        case "15":
          setIlluminationIntensity(Fluorescence730Intensity);
          setCameraExposure(Fluorescence730CameraExposure);
          break;
        default:
          break;
      }
    }, [illuminationChannel, BrightFieldIntensity, BrightFieldCameraExposure, Fluorescence405Intensity, Fluorescence405CameraExposure, Fluorescence488Intensity, Fluorescence488CameraExposure, Fluorescence561Intensity, Fluorescence561CameraExposure, Fluorescence638Intensity, Fluorescence638CameraExposure, Fluorescence730Intensity, Fluorescence730CameraExposure]);
     
    const activatePenTool = () => {
      setIsPenActive(!isPenActive);
      setIsFirstClick(true); // Reset to first click whenever the tool is activated
      document.body.style.cursor = isPenActive ? 'default' : 'crosshair';
      appendLog(isPenActive ? 'Pen tool deactivated.' : 'Pen tool activated. Click on the image to segment a cell.');
    };

    const updateUIBasedOnStatus = (status) => {
      setXPosition(status.current_x);
      setYPosition(status.current_y);
      setZPosition(status.current_z);
      setIsLightOn(status.is_illumination_on);
      setBrightFieldIntensity(status.BF_intensity_exposure[0]);
      setBrightFieldCameraExposure(status.BF_intensity_exposure[1]);
      setFluorescence405Intensity(status.F405_intensity_exposure[0]);
      setFluorescence405CameraExposure(status.F405_intensity_exposure[1]);
      setFluorescence488Intensity(status.F488_intensity_exposure[0]);
      setFluorescence488CameraExposure(status.F488_intensity_exposure[1]);
      setFluorescence561Intensity(status.F561_intensity_exposure[0]);
      setFluorescence561CameraExposure(status.F561_intensity_exposure[1]);
      setFluorescence638Intensity(status.F638_intensity_exposure[0]);
      setFluorescence638CameraExposure(status.F638_intensity_exposure[1]);
      setFluorescence730Intensity(status.F730_intensity_exposure[0]);
      setFluorescence730CameraExposure(status.F730_intensity_exposure[1]);
      //console.log(status);
    };

    const updateParameters = async (updatedParams) => {
      if (!microscopeControl) return;
      try {
          appendLog('Updating parameters on the server...');
          const response = await microscopeControl.update_parameters_from_client(updatedParams);
          if (response.success) {
              appendLog('Parameters updated successfully.');
          } else {
              appendLog('Failed to update parameters.');
          }
      } catch (error) {
          appendLog(`Error updating parameters: ${error.message}`);
      }
  };
    const channelKeyMap = {
        "0": "BF_intensity_exposure",
        "11": "F405_intensity_exposure",
        "12": "F488_intensity_exposure",
        "14": "F561_intensity_exposure",
        "13": "F638_intensity_exposure",
        "15": "F730_intensity_exposure"
    };

    const updateParametersOnServer = async (updatedParams) => {
        if (!microscopeControl) return;
        try {
            await microscopeControl.update_parameters_from_client(updatedParams);
            appendLog(`Parameters updated on server: ${JSON.stringify(updatedParams)}`);
        } catch (error) {
            appendLog(`Error updating parameters on server: ${error.message}`);
        }
    };

    // Function to extract the segmented object using the mask
    const extractSegmentedObject = (originalImage, mask) => {
      return new Promise((resolve) => {
        // Create a canvas for the segmented object
        const objectCanvas = document.createElement('canvas');
        objectCanvas.width = originalWidth;
        objectCanvas.height = originalHeight;
        const objectCtx = objectCanvas.getContext('2d');

        // Load the original image
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = originalImage;

        img.onload = () => {
          // Draw the original image
          objectCtx.drawImage(img, 0, 0);
          
          // Load and apply the mask
          const maskImg = new Image();
          maskImg.src = `data:image/png;base64,${mask}`;
          
          maskImg.onload = () => {
            // Get image data
            const imageData = objectCtx.getImageData(0, 0, originalWidth, originalHeight);
            const maskCanvas = document.createElement('canvas');
            maskCanvas.width = originalWidth;
            maskCanvas.height = originalHeight;
            const maskCtx = maskCanvas.getContext('2d');
            maskCtx.drawImage(maskImg, 0, 0);
            const maskData = maskCtx.getImageData(0, 0, originalWidth, originalHeight).data;

            // Apply mask to original image
            for (let i = 0; i < imageData.data.length; i += 4) {
              // If mask pixel is black (0), make the image pixel transparent
              if (maskData[i] < 128) {
                imageData.data[i + 3] = 0; // Set alpha to 0
              }
            }

            // Put the masked image data back
            objectCtx.putImageData(imageData, 0, 0);

            // Convert the canvas to blob
            objectCanvas.toBlob((blob) => {
              blob.arrayBuffer().then(buffer => {
                resolve(new Uint8Array(buffer));
              });
            }, 'image/png');
          };
        };
      });
    };

    // Modified similarity search function
    const handleCellSimilaritySearch = async (mask) => {
      if (!similarityService || !snapshotImage) {
        appendLog('No image or service available for similarity search.');
        return;
      }

      setIsLoading(true);
      appendLog('Starting similarity search for selected cell...');

      try {
        // Extract the segmented object using the mask
        const segmentedObject = await extractSegmentedObject(snapshotImage, mask);
        // First, save the cell image with annotation
        const saveResult = await similarityService.save_cell_image(
          segmentedObject, 
          labelText || "" // Use the label if provided, empty string if not
        );
        if (saveResult.status === "error") {
          throw new Error(saveResult.message);
        }        
        // Then perform the similarity search
        const results = await similarityService.find_similar_cells(
          segmentedObject,
          parseInt(numSimilarResults)
        );

        if (results.status === "error") {
          throw new Error(results.message);
        }

        appendLog(`Found ${results.length} similar cells.`);
        setSearchResults(results);

      } catch (error) {
        appendLog(`Error searching for similar cells: ${error.message}`);
      } finally {
        setIsLoading(false);
      }
    };

    const handleImageClick = async (event) => {
      if (!isPenActive || !segmentService || !snapshotImage) return;
    
      const canvas = canvasRef.current;
    
      // Get click coordinates relative to the canvas
      const rect = canvas.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const clickY = event.clientY - rect.top;
    
      // Scale coordinates to the original image size
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const pointCoordinates = [clickX * scaleX, clickY * scaleY];
    
      appendLog(`Clicked at coordinates: (${pointCoordinates[0]}, ${pointCoordinates[1]})`);
  
      try {
          // Fetch the image data as a Blob
          const response = await fetch(snapshotImage);
          const blob = await response.blob();
  
          // Convert Blob to ArrayBuffer
          const arrayBuffer = await new Response(blob).arrayBuffer();
  
          // Convert ArrayBuffer to Uint8Array
          const uint8Array = new Uint8Array(arrayBuffer);
  
          let segmentedResult;
          if (isFirstClick) {
              // First click: Use compute_embedding_with_initial_segment with the selected model
              segmentedResult = await segmentService.compute_embedding_with_initial_segment(
                  selectedModel,
                  uint8Array,
                  [pointCoordinates],
                  [1]
              );
              setIsFirstClick(false);
          } else {
              // Subsequent clicks: Use segment_with_existing_embedding
              segmentedResult = await segmentService.segment_with_existing_embedding(
                  uint8Array,
                  [pointCoordinates],
                  [1]
              );
          }
  
          if (segmentedResult.error) {
              appendLog(`Segmentation error: ${segmentedResult.error}`);
              return;
          }
  
          // Ensure mask data is not empty or malformed
          const maskData = segmentedResult.mask;
          if (!maskData) {
              appendLog("Received empty mask data from the server.");
              return;
          }
  
          // Create an image element to decode base64 mask data
          const maskImage = new Image();
          maskImage.crossOrigin = "anonymous"; // Set cross-origin attribute
          maskImage.src = `data:image/png;base64,${maskData}`;
  
          maskImage.onload = () => {
            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
          
            // Create an offscreen canvas to read the mask image data
            const maskCanvas = document.createElement('canvas');
            maskCanvas.width = originalWidth;
            maskCanvas.height = originalHeight;
            const maskCtx = maskCanvas.getContext('2d');
            maskCtx.drawImage(maskImage, 0, 0, originalWidth, originalHeight);
          
            // Get the mask image data
            const maskImageData = maskCtx.getImageData(0, 0, originalWidth, originalHeight);
            const maskData = maskImageData.data;
          
            // Get the image data from the canvas
            const imageData = ctx.getImageData(0, 0, originalWidth, originalHeight);
            const data = imageData.data;
          
            const overlayColor = [255, 0, 255]; // Pink-purple color
            const alpha = 0.5; // Transparency (0 to 1)
          
            for (let i = 0; i < data.length; i += 4) {
              const maskValue = maskData[i]; // Mask is grayscale, so R=G=B
          
              if (maskValue > 128) { // Adjust threshold as needed
                // Apply overlay color with transparency
                data[i] = data[i] * (1 - alpha) + overlayColor[0] * alpha;
                data[i + 1] = data[i + 1] * (1 - alpha) + overlayColor[1] * alpha;
                data[i + 2] = data[i + 2] * (1 - alpha) + overlayColor[2] * alpha;
                // data[i + 3] remains the same
              }
            }
          
            // Put the modified image data back onto the canvas
            ctx.putImageData(imageData, 0, 0);
            // Draw the clicked point as a red circle
            ctx.beginPath();
            ctx.arc(pointCoordinates[0], pointCoordinates[1], 5, 0, 2 * Math.PI, false);
            ctx.fillStyle = 'red';
            ctx.fill();
          
            appendLog('Segmentation completed and displayed.');
          };
          
  
          maskImage.onerror = () => {
              appendLog("Failed to load mask image.");
          };
  
          if (segmentedResult.mask) {
            // Create label
            const labelText = prompt("Enter label for this cell:");
            if (labelText) {
              setLabels([...labels, {
                x: pointCoordinates[0],
                y: pointCoordinates[1],
                text: labelText,
                mask: segmentedResult.mask
              }]);
      
              // Draw label on canvas
              const ctx = canvas.getContext('2d');
              ctx.font = '14px Arial';
              ctx.fillStyle = 'white';
              ctx.fillRect(pointCoordinates[0], pointCoordinates[1] - 20, ctx.measureText(labelText).width + 10, 20);
              ctx.fillStyle = 'black';
              ctx.fillText(labelText, pointCoordinates[0] + 5, pointCoordinates[1] - 5);
      
              // Extract the segmented object and perform similarity search
              await handleCellSimilaritySearch(segmentedResult.mask, labelText);
            }
          }
      
        } catch (error) {
          appendLog(`Error: ${error.message}`);
        }
      };

    const handleSegmentAllCells = async () => {
      if (!segmentService || !snapshotImage) return;
    
      appendLog('Segmenting all cells in the image...');
      try {
        // Fetch the image data as a Blob
        const response = await fetch(snapshotImage);
        const blob = await response.blob();
    
        // Convert Blob to ArrayBuffer
        const arrayBuffer = await new Response(blob).arrayBuffer();
    
        // Convert ArrayBuffer to Uint8Array
        const uint8Array = new Uint8Array(arrayBuffer);
    
        // Use the segmentation service to segment all cells
        const segmentedResult = await segmentService.segment_all_cells(selectedModel, uint8Array);
    
        if (segmentedResult.error) {
          appendLog(`Segmentation error: ${segmentedResult.error}`);
          return;
        }
    
        // Process the bounding boxes and masks from the segmentation result
        const boundingBoxes = segmentedResult.bounding_boxes;
        const masks = segmentedResult.masks;
    
        if (!boundingBoxes || boundingBoxes.length === 0) {
          appendLog("No cells found for segmentation.");
          return;
        }
    
        // Draw masks on the canvas
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
    
        // Get the current image data from the canvas
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
    
        for (let index = 0; index < masks.length; index++) {
          // Load the mask image
          const maskImage = new Image();
          maskImage.crossOrigin = "anonymous";
          maskImage.src = `data:image/png;base64,${masks[index]}`;
    
          await new Promise((resolve) => {
            maskImage.onload = () => {
              // Create an offscreen canvas to read the mask image data
              const maskCanvas = document.createElement('canvas');
              maskCanvas.width = canvas.width;
              maskCanvas.height = canvas.height;
              const maskCtx = maskCanvas.getContext('2d');
              maskCtx.drawImage(maskImage, 0, 0, canvas.width, canvas.height);
    
              // Get the mask image data
              const maskImageData = maskCtx.getImageData(0, 0, canvas.width, canvas.height);
              const maskData = maskImageData.data;
    
              const overlayColor = [0, 255, 0]; // Green color
              const alpha = 0.3; // Transparency (0 to 1)
    
              for (let i = 0; i < data.length; i += 4) {
                const maskValue = maskData[i]; // Mask is grayscale, so R=G=B
    
                if (maskValue > 128) { // Adjust threshold as needed
                  // Apply overlay color with transparency
                  data[i] = data[i] * (1 - alpha) + overlayColor[0] * alpha;
                  data[i + 1] = data[i + 1] * (1 - alpha) + overlayColor[1] * alpha;
                  data[i + 2] = data[i + 2] * (1 - alpha) + overlayColor[2] * alpha;
                  // data[i + 3] remains the same
                }
              }
    
              resolve();
            };
            maskImage.onerror = () => {
              appendLog("Failed to load mask image.");
              resolve();
            };
          });
        }
    
        // Put the modified image data back onto the canvas
        ctx.putImageData(imageData, 0, 0);
    
        appendLog('All cells segmented, masks overlaid with transparency.');
      } catch (error) {
        appendLog(`Error in segmenting all cells: ${error.message}`);
      }
    };
  
    const handleResetEmbedding = async () => {
      if (!segmentService) return;
    
      appendLog('Resetting embedding...');
      try {
        const result = await segmentService.reset_embedding();
        if (result) {
          appendLog('Embedding reset successfully.');
        } else {
          appendLog('No embedding was found to reset.');
        }
    
        // Clear the canvas
        const canvas = canvasRef.current;
        if (canvas) {
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          appendLog('Canvas cleared.');
        }
      } catch (error) {
        appendLog(`Error resetting embedding: ${error.message}`);
      }
    };

    const handleSimilaritySearch = async () => {
      console.log(
        snapshotImage,
        similarityService,
        numSimilarResults
      );

      if (!snapshotImage || !similarityService) {
        appendLog('No image or service available for similarity search.');
        return;
      }
      setIsLoading(true);
      appendLog('Starting similarity search...');
      try {
          // Fetch the image data as a Blob
          const response = await fetch(snapshotImage);
          const blob = await response.blob();
          // Convert Blob to ArrayBuffer
          const arrayBuffer = await new Response(blob).arrayBuffer();
          // Convert ArrayBuffer to Uint8Array
          const uint8Array = new Uint8Array(arrayBuffer);
          const imageData = {
              name: 'snapshot'
          };
          const results = await similarityService.find_similar_images(uint8Array, imageData, parseInt(numSimilarResults));
          appendLog(`Found ${results.length} similar images.`);
          // Save the results to the state
          setSearchResults(results);
      } catch (error) {
          appendLog(`Error searching for similar images: ${error.message}`);
      } finally {
          setIsLoading(false);
      }
    };

    const startDrawing = (event) => {
      if (!isBoxSelectionActive) return;
      const canvas = canvasRef.current;
      const rect = canvas.getBoundingClientRect();
      
      // Calculate the scale factors
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      setIsDrawing(true);
      setStartPoint({
        x: (event.clientX - rect.left) * scaleX,
        y: (event.clientY - rect.top) * scaleY
      });
    };
    
    const drawBox = (event) => {
      if (!isDrawing || !isBoxSelectionActive) return;
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      
      // Calculate the scale factors
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      // Create a cached image if it doesn't exist
      if (!canvas.cachedImage) {
        const img = new Image();
        img.src = snapshotImage;
        canvas.cachedImage = img;
      }
      
      // Clear and redraw only when the image is loaded
      if (canvas.cachedImage.complete) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(canvas.cachedImage, 0, 0, canvas.width, canvas.height);
        
        // Draw existing annotations
        annotations.forEach(ann => {
          ctx.strokeStyle = 'red';
          ctx.lineWidth = 2;
          ctx.strokeRect(ann.x, ann.y, ann.width, ann.height);
          ctx.fillStyle = 'white';
          ctx.fillRect(ann.x + ann.width + 5, ann.y, 100, 20);
          ctx.fillStyle = 'black';
          ctx.fillText(ann.text, ann.x + ann.width + 10, ann.y + 15);
        });
        
        // Draw current box with scaled coordinates
        const currentX = (event.clientX - rect.left) * scaleX;
        const currentY = (event.clientY - rect.top) * scaleY;
        
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.strokeRect(
          startPoint.x,
          startPoint.y,
          currentX - startPoint.x,
          currentY - startPoint.y
        );
      }
    };
    
    const endDrawing = (event) => {
      if (!isDrawing || !isBoxSelectionActive) return;
      setIsDrawing(false);
      
      const canvas = canvasRef.current;
      const rect = canvas.getBoundingClientRect();
      
      // Calculate the scale factors
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      const endX = (event.clientX - rect.left) * scaleX;
      const endY = (event.clientY - rect.top) * scaleY;
      
      const text = prompt('Enter annotation text:');
      if (text) {
        setAnnotations([...annotations, {
          x: startPoint.x,
          y: startPoint.y,
          width: endX - startPoint.x,
          height: endY - startPoint.y,
          text: text
        }]);
      }
    };

    const autoFocus = async () => {
      if (!microscopeControl) return;
      try {
        appendLog('Autofocusing...');
        await microscopeControl.auto_focus();
        appendLog('Autofocus completed.');
      } catch (error) {
        appendLog(`Error during autofocus: ${error.message}`);
      }
    };
    
    const snapImage = async () => {
      if (!microscopeControl) return;
      try {
        appendLog('Snapping image...');
        const imageUrl = await microscopeControl.snap(
          parseInt(cameraExposure),
          parseInt(illuminationChannel),
          parseInt(illuminationIntensity)
        );
        setSnapshotImage(imageUrl);
        appendLog('Image snapped successfully.');
        appendLog(`Image URL: ${imageUrl}`);
    
        // Draw the snapped image onto the canvas
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = imageUrl;
        img.onload = () => {
          const canvas = canvasRef.current;
          const ctx = canvas.getContext('2d');       
          canvas.width = img.naturalWidth;
          canvas.height = img.naturalHeight;
          
          // Clear the cached image
          canvas.cachedImage = null;
          
          ctx.drawImage(img, 0, 0);
        
          // Redraw existing annotations
          annotations.forEach(ann => {
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.strokeRect(ann.x, ann.y, ann.width, ann.height);
            ctx.fillStyle = 'white';
            ctx.fillRect(ann.x + ann.width + 5, ann.y, 100, 20);
            ctx.fillStyle = 'black';
            ctx.fillText(ann.text, ann.x + ann.width + 10, ann.y + 15);
          });
        
          canvas.style.width = '100%';
          canvas.style.height = 'auto';
        };
      } catch (error) {
        appendLog(`Error snapping image: ${error.message}`);
      }
    };
    
    

    const moveMicroscope = async (direction, multiplier) => {
        if (!microscopeControl) return;
        try {
            let moveX = 0, moveY = 0, moveZ = 0;
            if (direction === 'x') moveX = xMove * multiplier;
            else if (direction === 'y') moveY = yMove * multiplier;
            else if (direction === 'z') moveZ = zMove * multiplier;
            
            appendLog(`Attempting to move by: ${moveX}, ${moveY}, ${moveZ}`);
            const result = await microscopeControl.move_by_distance(moveX, moveY, moveZ);
            if (result.success) {
                appendLog(result.message);
                appendLog(`Moved from (${result.initial_position.x}, ${result.initial_position.y}, ${result.initial_position.z}) to (${result.final_position.x}, ${result.final_position.y}, ${result.final_position.z})`);
            } else {
                appendLog(`Move failed: ${result.message}`);
            }
        } catch (error) {
            appendLog(`Error in moveMicroscope: ${error.message}`);
        }
    };

    const moveToPosition = async () => {
        if (!microscopeControl) return;
        try {
            appendLog(`Attempting to move to position: (${xMove}, ${yMove}, ${zMove})`);
            const result = await microscopeControl.move_to_position(xMove, yMove, zMove);
            if (result.success) {
                appendLog(result.message);
                appendLog(`Moved from (${result.initial_position.x}, ${result.initial_position.y}, ${result.initial_position.z}) to (${result.final_position.x}, ${result.final_position.y}, ${result.final_position.z})`);
            } else {
                appendLog(`Move failed: ${result.message}`);
            }
        } catch (error) {
            appendLog(`Error in moveToPosition: ${error.message}`);
        }
    };

    const toggleLight = async () => {
        if (!microscopeControl) return;
        try {
            if (!isLightOn) {
                await microscopeControl.on_illumination();
                appendLog('Light turned on.');
            } else {
                await microscopeControl.off_illumination();
                appendLog('Light turned off.');
            }
            setIsLightOn(!isLightOn);
        } catch (error) {
            appendLog(`Error toggling light: ${error.message}`);
        }
    };

    const startPlateScan = async () => {
        if (!microscopeControl) return;
        try {
            if (!isPlateScanRunning) {
                await microscopeControl.scan_well_plate();
                appendLog('Plate scan started.');
            } else {
                await microscopeControl.stop_scan();
                appendLog('Plate scan stopped.');
            }
            setIsPlateScanRunning(!isPlateScanRunning);
        } catch (error) {
            appendLog(`Error in plate scan: ${error.message}`);
        }
    };

    const setIllumination = async () => {
        if (!microscopeControl) return;
        try {
            await microscopeControl.set_illumination(
                parseInt(illuminationChannel),
                parseInt(illuminationIntensity)
            );
            appendLog(`Illumination set: Channel ${illuminationChannel}, Intensity ${illuminationIntensity}%`);
        } catch (error) {
            appendLog(`Error setting illumination: ${error.message}`);
        }
    };

    const setCameraExposureTime = async () => {
        if (!microscopeControl) return;
        try {
            await microscopeControl.set_camera_exposure(parseInt(cameraExposure));
            appendLog(`Camera exposure set to ${cameraExposure}ms`);
        } catch (error) {
            appendLog(`Error setting camera exposure: ${error.message}`);
        }
    };

    const openChatbot = async () => {
      const url = await microscopeControl.get_chatbot_url();
      try {
        await window.initializeHyphaCore();
    
        if (!window.chatbotWindow || window.chatbotWindow.closed) {
          appendLog('Opening chatbot window...');
          window.chatbotWindow = await window.hyphaApi.createWindow({
            src: url,
            name: "Chatbot",
          });
        }
      } catch (error) {
        appendLog(`Failed to open chatbot window: ${error.message}`);
      }
    };

    return (
      <div>
        {/* Image Display Window */}
        <div id="image-display">
          {snapshotImage ? (
            <canvas
              ref={canvasRef}
              width={originalWidth}
              height={originalHeight}
              onClick={handleImageClick}
              onMouseDown={startDrawing}
              onMouseMove={drawBox}
              onMouseUp={endDrawing}
              style={{ 
                cursor: isPenActive ? 'crosshair' : isBoxSelectionActive ? 'crosshair' : 'pointer', 
                width: '100%', 
                height: '100%' 
              }}
            ></canvas>
          ) : (
            <p className="placeholder-text">Image Display</p>
          )}
        </div>

        {/* Chatbot Button in Upper Corner */}
        <button
          id="open-chatbot"
          className="chatbot-button"
          onClick={openChatbot}
        >
          <i className="fas fa-comments icon"></i> Chatbot
        </button>


        {/* Control Panel and Chatbot Section */}
        <div id="control-chat-section">
          <h3 className="section-title">Manual Control</h3>
          <div id="manual-control-content">
                {/* Coordinate Container */}
                <div className="coordinate-container">
                  {/* X Coordinate Group */}
                  <div className="coordinate-group">
                    <input
                      type="text"
                      id="x-coord"
                      className="control-input"
                      placeholder="X Coord"
                      value={xPosition}
                      readOnly
                    />
                    <input
                      type="number"
                      className="control-input"
                      placeholder="Enter X value"
                      value={xMove}
                      onChange={(e) => setXMove(parseFloat(e.target.value))}
                    />
                    <div className="aligned-buttons">
                      <button
                        className="half-button"
                        onClick={() => moveMicroscope('x', -1)}
                        disabled={!microscopeControl}
                      >
                        <i className="fas fa-arrow-left"></i> X-
                      </button>
                      <button
                        className="half-button"
                        onClick={() => moveMicroscope('x', 1)}
                        disabled={!microscopeControl}
                      >
                        X+ <i className="fas fa-arrow-right"></i>
                      </button>
                    </div>
                  </div>
    
                  {/* Y Coordinate Group */}
                  <div className="coordinate-group">
                    <input
                      type="text"
                      id="y-coord"
                      className="control-input"
                      placeholder="Y Coord"
                      value={yPosition}
                      readOnly
                    />
                    <input
                      type="number"
                      className="control-input"
                      placeholder="Enter Y value"
                      value={yMove}
                      onChange={(e) => setYMove(parseFloat(e.target.value))}
                    />
                    <div className="aligned-buttons">
                      <button
                        className="half-button"
                        onClick={() => moveMicroscope('y', -1)}
                        disabled={!microscopeControl}
                      >
                        <i className="fas fa-arrow-down"></i> Y-
                      </button>
                      <button
                        className="half-button"
                        onClick={() => moveMicroscope('y', 1)}
                        disabled={!microscopeControl}
                      >
                        Y+ <i className="fas fa-arrow-up"></i>
                      </button>
                    </div>
                  </div>
    
                  {/* Z Coordinate Group */}
                  <div className="coordinate-group">
                    <input
                      type="text"
                      id="z-coord"
                      className="control-input"
                      placeholder="Z Coord"
                      value={zPosition}
                      readOnly
                    />
                    <input
                      type="number"
                      className="control-input"
                      placeholder="Enter Z value"
                      value={zMove}
                      onChange={(e) => setZMove(parseFloat(e.target.value))}
                    />
                    <div className="aligned-buttons">
                      <button
                        className="half-button"
                        onClick={() => moveMicroscope('z', -1)}
                        disabled={!microscopeControl}
                      >
                        <i className="fas fa-arrow-down"></i> Z-
                      </button>
                      <button
                        className="half-button"
                        onClick={() => moveMicroscope('z', 1)}
                        disabled={!microscopeControl}
                      >
                        Z+ <i className="fas fa-arrow-up"></i>
                      </button>
                    </div>
                  </div>
                </div>
    
                {/* Illumination Settings */}
                <div className="illumination-settings">
                  <div className="illumination-intensity">
                    <div className="intensity-label-row">
                      <label>Illumination Intensity: </label>
                      <span>{illuminationIntensity}%</span>
                    </div>
                    <input
                      type="range"
                      className="control-input"
                      min="0"
                      max="100"
                      value={illuminationIntensity}
                      onChange={(e) => {
                        const newIntensity = parseInt(e.target.value, 10);
                        setIlluminationIntensity(newIntensity);
                        const key = channelKeyMap[illuminationChannel];
                        if (key) {
                          updateParametersOnServer({ [key]: [newIntensity, cameraExposure] });
                        }
                        setIllumination(); // Call setIllumination when intensity changes
                      }}
                    />
                  </div>
    
                  <div className="illumination-channel">
                    <label>Illumination Channel:</label>
                    <select
                      className="control-input"
                      value={illuminationChannel}
                      onChange={(e) => {
                        setIlluminationChannel(e.target.value);
                        setIllumination(); // Call setIllumination when channel changes
                      }}
                    >
                      <option value="0">BF LED matrix full</option>
                      <option value="11">Fluorescence 405 nm Ex</option>
                      <option value="12">Fluorescence 488 nm Ex</option>
                      <option value="14">Fluorescence 561nm Ex</option>
                      <option value="13">Fluorescence 638nm Ex</option>
                      <option value="15">Fluorescence 730nm Ex</option>
                    </select>
                  </div>
                </div>
    
                {/* Camera Exposure Settings */}
                <div className="camera-exposure-settings">
                  <label>Camera Exposure:</label>
                  <input
                    type="number"
                    className="control-input camera-exposure-input"
                    value={cameraExposure}
                    onChange={(e) => {
                      const newExposure = parseInt(e.target.value, 10);
                      setCameraExposure(newExposure);
                      const key = channelKeyMap[illuminationChannel];
                      if (key) {
                        updateParametersOnServer({ [key]: [illuminationIntensity, newExposure] });
                      }
                    }}
                  />
                </div>
    
                {/* Control Buttons */}
                <div className="control-group">
                  <div className="horizontal-buttons">
                    <button
                      className="control-button"
                      onClick={toggleLight}
                      disabled={!microscopeControl}
                    >
                    <i className="fas fa-lightbulb icon"></i> {isLightOn ? 'Turn Light Off' : 'Turn Light On'}
                    </button>
                    <button
                      className="control-button"
                      onClick={autoFocus}
                      disabled={!microscopeControl}
                    >
                    <i className="fas fa-crosshairs icon"></i> Autofocus
                    </button>
                    <button
                      className="control-button snap-button"
                      onClick={snapImage}
                      disabled={!microscopeControl}
                    >
                      <i className="fas fa-camera icon"></i> Snap Image
                    </button>
                    <button
                    className="control-button reset-button"
                    style={{ marginTop: '15px' }}
                    onClick={handleResetEmbedding}
                    disabled={!segmentService}
                    >
                    <i className="fas fa-sync icon"></i> Reset
                  </button>
                  </div>
                </div>
              </div>
        </div>
        {/* Similarity Search and Actions Section */}
        <div id="action-similarity-container">
          <div id="similarity-search">
            <h3 className="section-title">Similarity Search</h3>
            <div>
              {isLoading ? (
                <p>Loading...</p>
              ) : searchResults.length > 0 ? (
                <div className="d-flex flex-wrap">
                  {searchResults.map((result, index) => (
                    <div key={index} className="p-2">
                      <img
                        src={`data:image/jpeg;base64,${result.image}`}
                        alt={`similar-img-${index}`}
                        className="img-thumbnail"
                        style={{ width: '100px', height: '100px' }}
                      />
                      <p>Similarity: {result.similarity.toFixed(2)}</p>
                    </div>
                  ))}
                </div>
              ) : (
                <p>Search results will appear here.</p>
              )}
            </div>
          </div>
          
          <div id="actions">
            <h3 className="section-title">Actions</h3>
            <div className="control-group">
              <button
                className="actions-button"
                onClick={handleSimilaritySearch}
                disabled={!snapshotImage}
              >
              <i className="fas fa-search icon"></i> Search Similar Images
              </button>
    
              <label htmlFor="segmentation-model" style={{ marginTop: '15px' }}>
                Select Segmentation Model:
              </label>
              <select
                id="segmentation-model"
                className="control-input"
                value={selectedModel}
                onChange={(e) => setSelectedModel(e.target.value)}
              >
                <option value="vit_b_lm">ViT-B LM</option>
                <option value="vit_l_lm">ViT-L LM</option>
                <option value="vit_b">ViT-B</option>
                <option value="vit_b_em_organelles">ViT-B EM Organelles</option>
              </select>
    
              <div className="actions-buttons" style={{ marginTop: '15px' }}>
                <button className="actions-button" onClick={activatePenTool}>
                  <i className="fas fa-draw-polygon icon"></i> {isPenActive ? 'Deactivate Pen' : 'Segment Cell'}
                </button>
                <button
                  className="actions-button"
                  onClick={handleSegmentAllCells}
                  disabled={!snapshotImage || !segmentService}
                >
                <i className="fas fa-layer-group icon"></i> Segment all Cells
                </button>
                <button
                  className="actions-button"
                  onClick={() => setIsBoxSelectionActive(!isBoxSelectionActive)}
                >
                  <i className="fas fa-vector-square icon"></i> {isBoxSelectionActive ? 'Disable Box Selection' : 'Enable Box Selection'}
                </button>                
              </div>
            </div>
          </div>
    

        </div>    
        {/* Log Section */}
        <div id="log-section">
          <h3>Log</h3>
          <div className="log-content">
            <pre id="log-text">{log}</pre>
          </div>
        </div>
      </div>
    );
};
ReactDOM.render(<MicroscopeControl />, document.getElementById('app'));

</script>
</body>
</html>
